import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import roc_curve, auc, precision_recall_curve, f1_score, confusion_matrix
import seaborn as sns
from imblearn.over_sampling import SMOTE
import os

class ModelTrainerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Model Trainer App")
        self.root.geometry("1200x800")

        self.df = None
        self.target_column = None

        self.create_widgets()

    def create_widgets(self):
        # File selection
        file_frame = ttk.Frame(self.root)
        file_frame.pack(pady=10)
        ttk.Button(file_frame, text="Load CSV", command=self.load_csv).pack()

        # Target selection
        target_frame = ttk.Frame(self.root)
        target_frame.pack(pady=10)
        ttk.Label(target_frame, text="Select Target Column:").pack(side=tk.LEFT)
        self.target_menu = ttk.Combobox(target_frame, state="readonly")
        self.target_menu.pack(side=tk.LEFT)

        # Model selection
        model_frame = ttk.Frame(self.root)
        model_frame.pack(pady=10)
        ttk.Label(model_frame, text="Select Model:").pack(side=tk.LEFT)
        self.model_var = tk.StringVar()
        self.model_menu = ttk.Combobox(model_frame, textvariable=self.model_var, values=["Logistic Regression", "Decision Tree", "Random Forest", "XGBoost"])
        self.model_menu.pack(side=tk.LEFT)

        # Scaling option
        scale_frame = ttk.Frame(self.root)
        scale_frame.pack(pady=10)
        ttk.Label(scale_frame, text="Scaling:").pack(side=tk.LEFT)
        self.scale_var = tk.StringVar()
        self.scale_menu = ttk.Combobox(scale_frame, textvariable=self.scale_var, values=["None", "StandardScaler", "MinMaxScaler"])
        self.scale_menu.current(0)
        self.scale_menu.pack(side=tk.LEFT)

        # Balancing option
        balance_frame = ttk.Frame(self.root)
        balance_frame.pack(pady=10)
        self.balance_var = tk.BooleanVar()
        ttk.Checkbutton(balance_frame, text="Apply SMOTE (Balance Data)", variable=self.balance_var).pack(side=tk.LEFT)

        # Train button
        ttk.Button(self.root, text="Train Model", command=self.train_model).pack(pady=20)

        # Canvas for plots
        self.canvas_frames = [ttk.Frame(self.root) for _ in range(4)]
        for frame in self.canvas_frames:
            frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.canvases = [None]*4

    def load_csv(self):
        file_path = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv")])
        if file_path:
            self.df = pd.read_csv(file_path)
            self.target_menu['values'] = self.df.columns.tolist()
            self.target_menu.current(0)
            messagebox.showinfo("Success", "CSV loaded successfully!")

    def train_model(self):
        self.target_column = self.target_menu.get()
        if self.df is None or self.df.empty or not self.target_column:
            messagebox.showerror("Error", "Please load a CSV and select a target column.")
            return
        

        X = self.df.drop(columns=[self.target_column])
        y = self.df[self.target_column]

        # Handle non-numeric columns
        X = pd.get_dummies(X)

        # Apply scaling
        scaler_choice = self.scale_var.get()
        if scaler_choice == "StandardScaler":
            scaler = StandardScaler()
            X = scaler.fit_transform(X)
        elif scaler_choice == "MinMaxScaler":
            scaler = MinMaxScaler()
            X = scaler.fit_transform(X)

        # Train-test split
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

        # Apply SMOTE
        if self.balance_var.get():
            smote = SMOTE(random_state=42)
            X_train, y_train = smote.fit_resample(X_train, y_train)

        model_type = self.model_var.get()
        if model_type == "Logistic Regression":
            model = LogisticRegression(max_iter=1000)
        elif model_type == "Decision Tree":
            model = DecisionTreeClassifier()
        elif model_type == "Random Forest":
            model = RandomForestClassifier()
        elif model_type == "XGBoost":
            model = XGBClassifier(use_label_encoder=False, eval_metric='logloss')
        else:
            messagebox.showerror("Error", "Please select a valid model.")
            return

        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        y_prob = model.predict_proba(X_test)[:, 1]

        # Plotting
        self.plot_roc_curve(y_test, y_prob, 0)
        self.plot_pr_curve(y_test, y_prob, 1)
        self.plot_f1_score(y_test, y_pred, 2)
        self.plot_confusion_matrix(y_test, y_pred, 3)

    def plot_roc_curve(self, y_test, y_prob, idx):
        fpr, tpr, _ = roc_curve(y_test, y_prob)
        roc_auc = auc(fpr, tpr)
        fig, ax = plt.subplots()
        ax.plot(fpr, tpr, label=f'AUC = {roc_auc:.2f}')
        ax.plot([0, 1], [0, 1], linestyle='--')
        ax.set_title('ROC Curve')
        ax.set_xlabel('False Positive Rate')
        ax.set_ylabel('True Positive Rate')
        ax.legend()
        self.show_plot(fig, idx)

    def plot_pr_curve(self, y_test, y_prob, idx):
        precision, recall, _ = precision_recall_curve(y_test, y_prob)
        fig, ax = plt.subplots()
        ax.plot(recall, precision)
        ax.set_title('Precision-Recall Curve')
        ax.set_xlabel('Recall')
        ax.set_ylabel('Precision')
        self.show_plot(fig, idx)

    def plot_f1_score(self, y_test, y_pred, idx):
        score = f1_score(y_test, y_pred)
        fig, ax = plt.subplots()
        ax.bar(['F1 Score'], [score])
        ax.set_ylim([0, 1])
        ax.set_title('F1 Score')
        self.show_plot(fig, idx)

    def plot_confusion_matrix(self, y_test, y_pred, idx):
        cm = confusion_matrix(y_test, y_pred)
        fig, ax = plt.subplots()
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=ax)
        ax.set_title('Confusion Matrix')
        ax.set_xlabel('Predicted')
        ax.set_ylabel('Actual')
        self.show_plot(fig, idx)

    def show_plot(self, fig, idx):
        if self.canvases[idx]:
            self.canvases[idx].get_tk_widget().destroy()
        canvas = FigureCanvasTkAgg(fig, master=self.canvas_frames[idx])
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        self.canvases[idx] = canvas

if __name__ == '__main__':
    root = tk.Tk()
    app = ModelTrainerApp(root)
    root.mainloop()
